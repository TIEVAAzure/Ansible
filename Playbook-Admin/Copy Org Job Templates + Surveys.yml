---
- name: "AWX: Copy Job Templates + Surveys (Bootstrap-aware, Selection + Dry Run) - URI based"
  hosts: localhost
  gather_facts: false
  collections:
    - awx.awx

  vars:
    # ---------------------------------------------------------------------
    # Bootstrap-created objects (naming convention)
    # ---------------------------------------------------------------------
    target_project_name: "{{ target_org_name }} - TIEVAAzure-Ansible"
    target_localhost_inventory_name: "{{ target_org_name }} - Localhost"
    source_localhost_inventory_name: "Localhost"

    # ---------------------------------------------------------------------
    # Behaviour toggles (set via Survey)
    # ---------------------------------------------------------------------
    dry_run: false
    debug_mode: false

    allow_only_localhost_inventory_mapping: true
    create_templates_without_missing_creds: true

    # Selection
    copy_all_templates: false
    template_include: ""   # e.g. "AZ*,AVD*"
    template_exclude: "Admin*"

    # ---------------------------------------------------------------------
    # Controller connection (from Survey / JT vars)
    # ---------------------------------------------------------------------
    controller_host: "{{ tower_host }}"
    controller_token: "{{ tower_oauth_token }}"
    controller_validate_certs: "{{ tower_verify_ssl | default(true) | bool }}"

    # API base
    api_base: "{{ controller_host | regex_replace('/+$', '') }}/api/v2"

    # Paging
    page_size: 200

  tasks:
    # ---------------------------------------------------------------------
    # Guards
    # ---------------------------------------------------------------------
    - name: Guard - controller vars present
      ansible.builtin.assert:
        that:
          - controller_host is defined and (controller_host | length > 0)
          - controller_token is defined and (controller_token | length > 0)
        fail_msg: "Missing tower_host / tower_oauth_token (set via Survey or JT vars)."

    - name: Guard - org vars present
      ansible.builtin.assert:
        that:
          - source_org_name is defined and (source_org_name | length > 0)
          - target_org_name is defined and (target_org_name | length > 0)
        fail_msg: "source_org_name and target_org_name are required."

    - name: Debug - show selection inputs
      ansible.builtin.debug:
        msg:
          - "copy_all_templates={{ copy_all_templates | bool }}"
          - "template_include='{{ template_include | default('') }}'"
          - "template_exclude='{{ template_exclude | default('') }}'"
          - "dry_run={{ dry_run | bool }}"
          - "debug_mode={{ debug_mode | bool }}"
      when: debug_mode | bool

    # ---------------------------------------------------------------------
    # Small helper: build wildcard -> regex safely
    # ---------------------------------------------------------------------
    - name: Parse include/exclude patterns (comma-separated)
      ansible.builtin.set_fact:
        include_patterns: >-
          {{
            (template_include | default('') | string)
            | split(',')
            | map('trim')
            | reject('equalto', '')
            | list
          }}
        exclude_patterns: >-
          {{
            (template_exclude | default('') | string)
            | split(',')
            | map('trim')
            | reject('equalto', '')
            | list
          }}

    - name: Convert wildcard patterns to regex (safe)
      ansible.builtin.set_fact:
        include_regexes: >-
          {{
            include_patterns
            | map('regex_escape')
            | map('regex_replace', '\\\\*', '.*')
            | map('regex_replace', '\\\\?', '.')
            | map('regex_replace', '^(.*)$', '^\\1$')
            | list
          }}
        exclude_regexes: >-
          {{
            exclude_patterns
            | map('regex_escape')
            | map('regex_replace', '\\\\*', '.*')
            | map('regex_replace', '\\\\?', '.')
            | map('regex_replace', '^(.*)$', '^\\1$')
            | list
          }}

    - name: Debug - show computed regexes
      ansible.builtin.debug:
        msg:
          - "include_regexes={{ include_regexes }}"
          - "exclude_regexes={{ exclude_regexes }}"
      when: debug_mode | bool

    # ---------------------------------------------------------------------
    # API Lookups via URI (no dependency on controller_api/tower_api modules)
    # ---------------------------------------------------------------------
    - name: Lookup source org (by name)
      ansible.builtin.uri:
        url: "{{ api_base }}/organizations/?name={{ source_org_name | urlencode }}"
        method: GET
        headers:
          Authorization: "Bearer {{ controller_token }}"
          Accept: "application/json"
        validate_certs: "{{ controller_validate_certs }}"
        return_content: true
      register: src_org_rsp

    - name: Lookup target org (by name)
      ansible.builtin.uri:
        url: "{{ api_base }}/organizations/?name={{ target_org_name | urlencode }}"
        method: GET
        headers:
          Authorization: "Bearer {{ controller_token }}"
          Accept: "application/json"
        validate_certs: "{{ controller_validate_certs }}"
        return_content: true
      register: dst_org_rsp

    - name: Guard - org lookups returned exactly one result each
      ansible.builtin.assert:
        that:
          - (src_org_rsp.json.count | int) == 1
          - (dst_org_rsp.json.count | int) == 1
        fail_msg: "Expected exactly 1 org for source and target. Check spelling / duplicates."

    - name: Set org IDs
      ansible.builtin.set_fact:
        source_org_id: "{{ src_org_rsp.json.results[0].id }}"
        target_org_id: "{{ dst_org_rsp.json.results[0].id }}"

    - name: Lookup target project (bootstrap created)
      ansible.builtin.uri:
        url: "{{ api_base }}/projects/?organization={{ target_org_id }}&name={{ target_project_name | urlencode }}"
        method: GET
        headers:
          Authorization: "Bearer {{ controller_token }}"
          Accept: "application/json"
        validate_certs: "{{ controller_validate_certs }}"
        return_content: true
      register: dst_project_rsp

    - name: Guard - target project exists
      ansible.builtin.assert:
        that:
          - (dst_project_rsp.json.count | int) == 1
        fail_msg: "Target project '{{ target_project_name }}' not found. Run bootstrap first."

    - name: Lookup target localhost inventory (bootstrap created)
      ansible.builtin.uri:
        url: "{{ api_base }}/inventories/?organization={{ target_org_id }}&name={{ target_localhost_inventory_name | urlencode }}"
        method: GET
        headers:
          Authorization: "Bearer {{ controller_token }}"
          Accept: "application/json"
        validate_certs: "{{ controller_validate_certs }}"
        return_content: true
      register: dst_inv_rsp

    - name: Guard - target localhost inventory exists
      ansible.builtin.assert:
        that:
          - (dst_inv_rsp.json.count | int) == 1
        fail_msg: "Target inventory '{{ target_localhost_inventory_name }}' not found. Run bootstrap first."

    # ---------------------------------------------------------------------
    # Fetch ALL creds in target org (paged)
    # ---------------------------------------------------------------------
    - name: Init target creds paging
      ansible.builtin.set_fact:
        _creds_next: "{{ api_base }}/credentials/?organization={{ target_org_id }}&page_size={{ page_size }}"
        dst_creds_all: []

    - name: Page target creds until done
      ansible.builtin.uri:
        url: "{{ _creds_next }}"
        method: GET
        headers:
          Authorization: "Bearer {{ controller_token }}"
          Accept: "application/json"
        validate_certs: "{{ controller_validate_certs }}"
        return_content: true
      register: _creds_page
      until: _creds_next is none
      retries: 200
      delay: 0
      changed_when: false
      vars:
        _dummy: "{{ 0 }}"
      # Update next + accumulate after each page
      # (done with set_fact tasks immediately after)

    - name: Accumulate creds page + advance next (loop style)
      ansible.builtin.set_fact:
        dst_creds_all: "{{ dst_creds_all + (_creds_page.json.results | default([])) }}"
        _creds_next: "{{ _creds_page.json.next | default(None) }}"
      changed_when: false

    - name: Build target credential name->id map
      ansible.builtin.set_fact:
        dst_cred_map: >-
          {{
            dict(
              (dst_creds_all | default([])) | map(attribute='name')
              | zip((dst_creds_all | default([])) | map(attribute='id'))
            )
          }}

    # ---------------------------------------------------------------------
    # Fetch ALL job templates in source org (paged)
    # ---------------------------------------------------------------------
    - name: Init source JT paging
      ansible.builtin.set_fact:
        _jt_next: "{{ api_base }}/job_templates/?organization={{ source_org_id }}&page_size={{ page_size }}"
        src_jt_all: []

    - name: Page source job templates until done
      ansible.builtin.uri:
        url: "{{ _jt_next }}"
        method: GET
        headers:
          Authorization: "Bearer {{ controller_token }}"
          Accept: "application/json"
        validate_certs: "{{ controller_validate_certs }}"
        return_content: true
      register: _jt_page
      until: _jt_next is none
      retries: 200
      delay: 0
      changed_when: false

    - name: Accumulate JT page + advance next
      ansible.builtin.set_fact:
        src_jt_all: "{{ src_jt_all + (_jt_page.json.results | default([])) }}"
        _jt_next: "{{ _jt_page.json.next | default(None) }}"
      changed_when: false

    - name: Build available template names (for debug)
      ansible.builtin.set_fact:
        available_template_names: "{{ src_jt_all | map(attribute='name') | list }}"

    # ---------------------------------------------------------------------
    # Selection (done safely with a loop â€” no fancy regex group building)
    # ---------------------------------------------------------------------
    - name: Initialise selection
      ansible.builtin.set_fact:
        selected_templates: []

    - name: Select templates (apply include/exclude unless copy_all_templates=true)
      ansible.builtin.set_fact:
        selected_templates: "{{ selected_templates + [item] }}"
      loop: "{{ src_jt_all }}"
      loop_control:
        label: "{{ item.name }}"
      vars:
        _name: "{{ item.name | default('') }}"
        _include_hit: >-
          {{
            (copy_all_templates | bool)
            or
            (
              (include_regexes | length) > 0
              and
              (include_regexes | select('search', _name) | list | length > 0)
            )
          }}
        _exclude_hit: >-
          {{
            (exclude_regexes | length) > 0
            and
            (exclude_regexes | select('search', _name) | list | length > 0)
          }}
      when:
        - _name | length > 0
        - _include_hit
        - not _exclude_hit

    - name: Debug - selection summary (and first 50 names if needed)
      ansible.builtin.debug:
        msg:
          - "Available templates in source org: {{ available_template_names | length }}"
          - "Selected templates: {{ selected_templates | length }}"
          - "First 50 available names:"
          - "{{ available_template_names[:50] }}"
      when: debug_mode | bool or (selected_templates | length) == 0

    - name: Guard - selection not empty
      ansible.builtin.assert:
        that:
          - (selected_templates | length) > 0
        fail_msg: >
          No templates matched selection.
          You used: copy_all_templates={{ copy_all_templates | bool }},
          include='{{ template_include }}', exclude='{{ template_exclude }}'.
          TIP: use include like 'AZ*,AVD*' (no spaces), or enable debug_mode to see names.

    - name: Set selected template names (for reporting)
      ansible.builtin.set_fact:
        selected_template_names: "{{ selected_templates | map(attribute='name') | list }}"

    - name: Dry run - list what would be copied
      ansible.builtin.debug:
        msg:
          - "DRY RUN: would copy {{ selected_template_names | length }} templates:"
          - "{{ selected_template_names }}"
      when: dry_run | bool

    - name: Stop after dry run
      ansible.builtin.meta: end_play
      when: dry_run | bool

    # ---------------------------------------------------------------------
    # Copy templates
    # ---------------------------------------------------------------------
    - name: Initialise tracking
      ansible.builtin.set_fact:
        copied_templates: []
        templates_missing_creds: {}
        templates_inventory_not_mapped: []

    - name: Copy selected templates into target org
      loop: "{{ selected_templates }}"
      loop_control:
        label: "{{ item.name }}"
      vars:
        src_template_id: "{{ item.id }}"
      block:
        - name: Fetch template detail
          ansible.builtin.uri:
            url: "{{ api_base }}/job_templates/{{ src_template_id }}/"
            method: GET
            headers:
              Authorization: "Bearer {{ controller_token }}"
              Accept: "application/json"
            validate_certs: "{{ controller_validate_certs }}"
            return_content: true
          register: jt_detail

        - name: Fetch template survey spec (ignore if not present)
          ansible.builtin.uri:
            url: "{{ api_base }}/job_templates/{{ src_template_id }}/survey_spec/"
            method: GET
            headers:
              Authorization: "Bearer {{ controller_token }}"
              Accept: "application/json"
            validate_certs: "{{ controller_validate_certs }}"
            return_content: true
            status_code: [200, 404]
          register: jt_survey
          changed_when: false

        - name: Compute credential mapping + inventory mapping
          ansible.builtin.set_fact:
            src_cred_names: "{{ (jt_detail.json.summary_fields.credentials | default([])) | map(attribute='name') | list }}"
            missing_cred_names: "{{ src_cred_names | reject('in', (dst_cred_map.keys() | list)) | list }}"
            matched_cred_ids: "{{ src_cred_names | reject('in', missing_cred_names) | map('extract', dst_cred_map) | list }}"
            src_inv_name: "{{ jt_detail.json.summary_fields.inventory.name | default('') }}"
            mapped_inventory_name: >-
              {{
                (src_inv_name == source_localhost_inventory_name)
                | ternary(target_localhost_inventory_name, omit)
              }}

        - name: Log missing creds (if any)
          ansible.builtin.set_fact:
            templates_missing_creds: "{{ templates_missing_creds | combine({ jt_detail.json.name: missing_cred_names }) }}"
          when: (missing_cred_names | length) > 0

        - name: Log inventory not mapped (non-localhost inventory)
          ansible.builtin.set_fact:
            templates_inventory_not_mapped: "{{ templates_inventory_not_mapped + [jt_detail.json.name] }}"
          when:
            - allow_only_localhost_inventory_mapping | bool
            - (src_inv_name | length) > 0
            - (src_inv_name != source_localhost_inventory_name)

        - name: Create/Update job template in target org
          awx.awx.job_template:
            name: "{{ jt_detail.json.name }}"
            description: "{{ jt_detail.json.description | default('') }}"
            organization: "{{ target_org_name }}"
            state: present

            project: "{{ target_project_name }}"
            playbook: "{{ jt_detail.json.playbook }}"

            inventory: >-
              {{
                (allow_only_localhost_inventory_mapping | bool)
                | ternary(mapped_inventory_name, omit)
              }}

            execution_environment: "{{ jt_detail.json.summary_fields.execution_environment.name | default(omit) }}"

            job_type: "{{ jt_detail.json.job_type | default('run') }}"
            become_enabled: "{{ jt_detail.json.become_enabled | default(false) }}"
            diff_mode: "{{ jt_detail.json.diff_mode | default(false) }}"
            allow_simultaneous: "{{ jt_detail.json.allow_simultaneous | default(false) }}"

            ask_credential_on_launch: "{{ jt_detail.json.ask_credential_on_launch | default(false) }}"
            ask_inventory_on_launch: "{{ jt_detail.json.ask_inventory_on_launch | default(false) }}"
            ask_variables_on_launch: "{{ jt_detail.json.ask_variables_on_launch | default(false) }}"
            ask_limit_on_launch: "{{ jt_detail.json.ask_limit_on_launch | default(false) }}"
            ask_tags_on_launch: "{{ jt_detail.json.ask_tags_on_launch | default(false) }}"
            ask_skip_tags_on_launch: "{{ jt_detail.json.ask_skip_tags_on_launch | default(false) }}"
            ask_job_type_on_launch: "{{ jt_detail.json.ask_job_type_on_launch | default(false) }}"
            ask_verbosity_on_launch: "{{ jt_detail.json.ask_verbosity_on_launch | default(false) }}"
            ask_diff_mode_on_launch: "{{ jt_detail.json.ask_diff_mode_on_launch | default(false) }}"

            extra_vars: "{{ jt_detail.json.extra_vars | default(omit) }}"
            job_tags: "{{ jt_detail.json.job_tags | default('') }}"
            skip_tags: "{{ jt_detail.json.skip_tags | default('') }}"
            limit: "{{ jt_detail.json.limit | default('') }}"
            verbosity: "{{ jt_detail.json.verbosity | default(0) }}"

            survey_enabled: "{{ jt_detail.json.survey_enabled | default(false) }}"
            survey_spec: >-
              {{
                (jt_detail.json.survey_enabled | default(false) | bool)
                | ternary(
                    (jt_survey.json if (jt_survey.status | int) == 200 else omit),
                    omit
                  )
              }}

            credentials: >-
              {{
                ((missing_cred_names | length) == 0)
                | ternary(matched_cred_ids, omit)
              }}

            controller_host: "{{ controller_host }}"
            controller_oauthtoken: "{{ controller_token }}"
            validate_certs: "{{ controller_validate_certs }}"
          when:
            - (create_templates_without_missing_creds | bool) or ((missing_cred_names | length) == 0)

        - name: Mark template copied
          ansible.builtin.set_fact:
            copied_templates: "{{ copied_templates + [jt_detail.json.name] }}"

    # ---------------------------------------------------------------------
    # Summary
    # ---------------------------------------------------------------------
    - name: Copy summary
      ansible.builtin.debug:
        msg:
          - "Copy complete. Source org='{{ source_org_name }}' -> Target org='{{ target_org_name }}'"
          - "Templates selected: {{ selected_template_names | length }}"
          - "Templates copied: {{ copied_templates | length }}"
          - "Templates with missing creds (created without creds): {{ templates_missing_creds | length }}"
          - "Templates with inventory not mapped (needs phase 2): {{ templates_inventory_not_mapped | length }}"