---
- name: "AWX: Copy Job Templates + Surveys (Bootstrap-aware, with Selection + Dry Run) - API only"
  hosts: localhost
  gather_facts: false

  vars:
    # ---------------------------------------------------------------------
    # Bootstrap-created objects (naming convention)
    # ---------------------------------------------------------------------
    target_project_name: "{{ target_org_name }} - TIEVAAzure-Ansible"
    target_localhost_inventory_name: "{{ target_org_name }} - Localhost"
    source_localhost_inventory_name: "Localhost"   # how it appears in MASTER org templates

    # ---------------------------------------------------------------------
    # Behaviour toggles (set via AWX Survey)
    # ---------------------------------------------------------------------
    dry_run: false
    debug_mode: false

    allow_only_localhost_inventory_mapping: true
    create_templates_without_missing_creds: true

    # Template selection
    copy_all_templates: false
    template_include: ""   # e.g. "AZ*,AVD*"
    template_exclude: "Admin*"   # default

    # ---------------------------------------------------------------------
    # Controller connection (from Survey / Variables)
    # ---------------------------------------------------------------------
    tower_verify_ssl: true

    # ---------------------------------------------------------------------
    # Internal
    # ---------------------------------------------------------------------
    awx_api_base: "{{ tower_host | regex_replace('/+$','') }}/api/v2"
    awx_headers:
      Authorization: "Bearer {{ tower_oauth_token }}"
      Content-Type: "application/json"

  tasks:
    # ---------------------------------------------------------------------
    # Guards
    # ---------------------------------------------------------------------
    - name: Guard - ensure controller connection is available
      ansible.builtin.assert:
        that:
          - tower_host is defined and (tower_host | length > 0)
          - tower_oauth_token is defined and (tower_oauth_token | length > 0)
        fail_msg: >
          Controller connection not configured.
          Provide tower_host and tower_oauth_token via the Job Template Variables/Survey.

    - name: Guard - ensure org inputs provided
      ansible.builtin.assert:
        that:
          - source_org_name is defined and (source_org_name | length > 0)
          - target_org_name is defined and (target_org_name | length > 0)
        fail_msg: "source_org_name and target_org_name are required."

    - name: Debug - show raw selection inputs
      ansible.builtin.debug:
        msg:
          - "copy_all_templates={{ copy_all_templates | bool }}"
          - "template_include='{{ template_include | default('') }}'"
          - "template_exclude='{{ template_exclude | default('') }}'"
          - "dry_run={{ dry_run | bool }}"
          - "debug_mode={{ debug_mode | bool }}"
          - "awx_api_base={{ awx_api_base }}"
      when: debug_mode | bool

    # ---------------------------------------------------------------------
    # Helper: GET one page
    # ---------------------------------------------------------------------
    - name: Get source org
      ansible.builtin.uri:
        url: "{{ awx_api_base }}/organizations/?name={{ source_org_name | urlencode }}"
        method: GET
        headers: "{{ awx_headers }}"
        validate_certs: "{{ tower_verify_ssl | bool }}"
        return_content: true
      register: src_org_rsp

    - name: Get target org
      ansible.builtin.uri:
        url: "{{ awx_api_base }}/organizations/?name={{ target_org_name | urlencode }}"
        method: GET
        headers: "{{ awx_headers }}"
        validate_certs: "{{ tower_verify_ssl | bool }}"
        return_content: true
      register: dst_org_rsp

    - name: Guard - org lookups returned exactly one result each
      ansible.builtin.assert:
        that:
          - (src_org_rsp.json.count | int) == 1
          - (dst_org_rsp.json.count | int) == 1
        fail_msg: "Expected exactly 1 org result for both source and target. Check org names / duplicates."

    - name: Set org IDs
      ansible.builtin.set_fact:
        source_org_id: "{{ src_org_rsp.json.results[0].id }}"
        target_org_id: "{{ dst_org_rsp.json.results[0].id }}"

    # ---------------------------------------------------------------------
    # Target bootstrap objects
    # ---------------------------------------------------------------------
    - name: Lookup target project (bootstrap must have created it)
      ansible.builtin.uri:
        url: "{{ awx_api_base }}/projects/?organization={{ target_org_id }}&name={{ target_project_name | urlencode }}"
        method: GET
        headers: "{{ awx_headers }}"
        validate_certs: "{{ tower_verify_ssl | bool }}"
        return_content: true
      register: dst_project_rsp

    - name: Guard - target project exists
      ansible.builtin.assert:
        that:
          - (dst_project_rsp.json.count | int) == 1
        fail_msg: >
          Target project '{{ target_project_name }}' not found in org '{{ target_org_name }}'.
          Run bootstrap first (or fix naming).

    - name: Set target project ID
      ansible.builtin.set_fact:
        target_project_id: "{{ dst_project_rsp.json.results[0].id }}"

    - name: Lookup target localhost inventory (bootstrap must have created it)
      ansible.builtin.uri:
        url: "{{ awx_api_base }}/inventories/?organization={{ target_org_id }}&name={{ target_localhost_inventory_name | urlencode }}"
        method: GET
        headers: "{{ awx_headers }}"
        validate_certs: "{{ tower_verify_ssl | bool }}"
        return_content: true
      register: dst_inv_rsp

    - name: Guard - target localhost inventory exists
      ansible.builtin.assert:
        that:
          - (dst_inv_rsp.json.count | int) == 1
        fail_msg: >
          Target inventory '{{ target_localhost_inventory_name }}' not found in org '{{ target_org_name }}'.
          Run bootstrap first (or fix naming).

    - name: Set target localhost inventory ID
      ansible.builtin.set_fact:
        target_localhost_inventory_id: "{{ dst_inv_rsp.json.results[0].id }}"

    # ---------------------------------------------------------------------
    # Fetch ALL credentials in target org (pagination)
    # ---------------------------------------------------------------------
    - name: Init creds paging
      ansible.builtin.set_fact:
        _creds_next_url: "{{ awx_api_base }}/credentials/?organization={{ target_org_id }}&page_size=200"
        _creds_all: []

    - name: Page credentials
      ansible.builtin.uri:
        url: "{{ _creds_next_url }}"
        method: GET
        headers: "{{ awx_headers }}"
        validate_certs: "{{ tower_verify_ssl | bool }}"
        return_content: true
      register: _creds_page
      until: _creds_page.json.next is none
      retries: 50
      delay: 0
      failed_when: _creds_page.status not in [200]
      changed_when: false
      vars:
        _creds_next_url: "{{ _creds_next_url }}"
      notify: []
      when: _creds_next_url is not none
      # manual loop via set_fact in "always" below
      always:
        - name: Append creds + advance pointer
          ansible.builtin.set_fact:
            _creds_all: "{{ _creds_all + (_creds_page.json.results | default([])) }}"
            _creds_next_url: "{{ _creds_page.json.next }}"
          when: _creds_page is defined and _creds_page.json is defined

    - name: Build target credential name->id map
      ansible.builtin.set_fact:
        dst_cred_map: "{{ dict(_creds_all | map(attribute='name') | zip(_creds_all | map(attribute='id'))) }}"

    # ---------------------------------------------------------------------
    # Fetch ALL job templates in source org (pagination)
    # ---------------------------------------------------------------------
    - name: Init templates paging
      ansible.builtin.set_fact:
        _jt_next_url: "{{ awx_api_base }}/job_templates/?organization={{ source_org_id }}&page_size=200"
        _jt_all: []

    - name: Page job templates
      ansible.builtin.uri:
        url: "{{ _jt_next_url }}"
        method: GET
        headers: "{{ awx_headers }}"
        validate_certs: "{{ tower_verify_ssl | bool }}"
        return_content: true
      register: _jt_page
      until: _jt_page.json.next is none
      retries: 50
      delay: 0
      failed_when: _jt_page.status not in [200]
      changed_when: false
      vars:
        _jt_next_url: "{{ _jt_next_url }}"
      always:
        - name: Append templates + advance pointer
          ansible.builtin.set_fact:
            _jt_all: "{{ _jt_all + (_jt_page.json.results | default([])) }}"
            _jt_next_url: "{{ _jt_page.json.next }}"
          when: _jt_page is defined and _jt_page.json is defined

    - name: Build list of available source template names
      ansible.builtin.set_fact:
        available_template_names: "{{ _jt_all | map(attribute='name') | list }}"

    # ---------------------------------------------------------------------
    # Selection (wildcard include/exclude)
    # ---------------------------------------------------------------------
    - name: Parse include/exclude patterns
      ansible.builtin.set_fact:
        include_patterns: "{{ (template_include | default('') | string).split(',') | map('trim') | reject('equalto','') | list }}"
        exclude_patterns: "{{ (template_exclude | default('') | string).split(',') | map('trim') | reject('equalto','') | list }}"

    - name: Convert wildcard patterns to regex strings
      ansible.builtin.set_fact:
        include_regexes: >-
          {{
            include_patterns
            | map('regex_escape')
            | map('regex_replace', '\\\\\\*', '.*')
            | map('regex_replace', '\\\\\\?', '.')
            | map('regex_replace', '^(.*)$', '^\\1$')
            | list
          }}
        exclude_regexes: >-
          {{
            exclude_patterns
            | map('regex_escape')
            | map('regex_replace', '\\\\\\*', '.*')
            | map('regex_replace', '\\\\\\?', '.')
            | map('regex_replace', '^(.*)$', '^\\1$')
            | list
          }}

    - name: Build combined include/exclude regex
      ansible.builtin.set_fact:
        include_re: "{{ (copy_all_templates | bool) | ternary('.*', (include_regexes | length > 0) | ternary('(' ~ (include_regexes | join('|')) ~ ')', 'a^')) }}"
        exclude_re: "{{ (exclude_regexes | length > 0) | ternary('(' ~ (exclude_regexes | join('|')) ~ ')', 'a^') }}"

    - name: Select templates
      ansible.builtin.set_fact:
        selected_templates: "{{ _jt_all | selectattr('name','match',include_re) | rejectattr('name','match',exclude_re) | list }}"

    - name: Debug - selection summary
      ansible.builtin.debug:
        msg:
          - "Available templates in source org: {{ available_template_names | length }}"
          - "include_re={{ include_re }}"
          - "exclude_re={{ exclude_re }}"
          - "Selected templates after filters: {{ selected_templates | length }}"
          - "First 50 available template names:"
          - "{{ available_template_names[:50] }}"
      when: debug_mode | bool or (selected_templates | length) == 0

    - name: Guard - selection not empty
      ansible.builtin.assert:
        that:
          - (selected_templates | length) > 0
        fail_msg: >
          No templates matched your selection.
          You used: copy_all_templates={{ copy_all_templates | bool }},
          include='{{ template_include }}', exclude='{{ template_exclude }}'.
          TIP: Try include like 'AZ*,AVD*' (no spaces), or enable debug_mode to view template names.

    - name: Set selected template names
      ansible.builtin.set_fact:
        selected_template_names: "{{ selected_templates | map(attribute='name') | list }}"

    - name: Dry run - list what would be copied (names only)
      ansible.builtin.debug:
        msg:
          - "DRY RUN: would copy {{ selected_template_names | length }} templates from '{{ source_org_name }}' -> '{{ target_org_name }}':"
          - "{{ selected_template_names }}"
      when: dry_run | bool

    - name: Stop after dry run
      ansible.builtin.meta: end_play
      when: dry_run | bool

    # ---------------------------------------------------------------------
    # Copy loop
    # ---------------------------------------------------------------------
    - name: Initialise tracking
      ansible.builtin.set_fact:
        copied_templates: []
        templates_missing_creds: {}
        templates_inventory_not_mapped: []
        ee_cache: {}   # name -> id (best-effort)

    - name: Copy selected templates
      vars:
        src_template_id: "{{ item.id }}"
      block:
        - name: Get full template detail
          ansible.builtin.uri:
            url: "{{ awx_api_base }}/job_templates/{{ src_template_id }}/"
            method: GET
            headers: "{{ awx_headers }}"
            validate_certs: "{{ tower_verify_ssl | bool }}"
            return_content: true
          register: jt_detail

        - name: Get survey spec (if any)
          ansible.builtin.uri:
            url: "{{ awx_api_base }}/job_templates/{{ src_template_id }}/survey_spec/"
            method: GET
            headers: "{{ awx_headers }}"
            validate_certs: "{{ tower_verify_ssl | bool }}"
            return_content: true
          register: jt_survey
          failed_when: false
          changed_when: false

        - name: Compute credential mapping (by name)
          ansible.builtin.set_fact:
            src_cred_names: "{{ (jt_detail.json.summary_fields.credentials | default([])) | map(attribute='name') | list }}"
            missing_cred_names: "{{ src_cred_names | reject('in', (dst_cred_map.keys() | list)) | list }}"
            matched_cred_ids: "{{ src_cred_names | reject('in', missing_cred_names) | map('extract', dst_cred_map) | list }}"

        - name: Compute inventory mapping
          ansible.builtin.set_fact:
            src_inv_name: "{{ jt_detail.json.summary_fields.inventory.name | default('') }}"
            mapped_inventory_id: >-
              {{
                (src_inv_name == source_localhost_inventory_name)
                | ternary(target_localhost_inventory_id, omit)
              }}

        - name: Log missing creds
          ansible.builtin.set_fact:
            templates_missing_creds: "{{ templates_missing_creds | combine({ jt_detail.json.name: missing_cred_names }) }}"
          when: (missing_cred_names | length) > 0

        - name: Log inventory not mapped (non-localhost)
          ansible.builtin.set_fact:
            templates_inventory_not_mapped: "{{ templates_inventory_not_mapped + [jt_detail.json.name] }}"
          when:
            - allow_only_localhost_inventory_mapping | bool
            - (src_inv_name | length > 0)
            - (src_inv_name != source_localhost_inventory_name)

        - name: Lookup existing template in TARGET (by org + name)
          ansible.builtin.uri:
            url: "{{ awx_api_base }}/job_templates/?organization={{ target_org_id }}&name={{ jt_detail.json.name | urlencode }}"
            method: GET
            headers: "{{ awx_headers }}"
            validate_certs: "{{ tower_verify_ssl | bool }}"
            return_content: true
          register: dst_jt_lookup

        - name: Set target template id (if exists)
          ansible.builtin.set_fact:
            target_jt_id: "{{ (dst_jt_lookup.json.count | int) | ternary(dst_jt_lookup.json.results[0].id, omit) }}"
          when: (dst_jt_lookup.json.count | int) > 0

        - name: Build create/update payload
          ansible.builtin.set_fact:
            jt_payload:
              name: "{{ jt_detail.json.name }}"
              description: "{{ jt_detail.json.description | default('') }}"
              organization: "{{ target_org_id }}"
              project: "{{ target_project_id }}"
              playbook: "{{ jt_detail.json.playbook }}"
              job_type: "{{ jt_detail.json.job_type | default('run') }}"
              become_enabled: "{{ jt_detail.json.become_enabled | default(false) }}"
              diff_mode: "{{ jt_detail.json.diff_mode | default(false) }}"
              allow_simultaneous: "{{ jt_detail.json.allow_simultaneous | default(false) }}"
              ask_credential_on_launch: "{{ jt_detail.json.ask_credential_on_launch | default(false) }}"
              ask_inventory_on_launch: "{{ jt_detail.json.ask_inventory_on_launch | default(false) }}"
              ask_variables_on_launch: "{{ jt_detail.json.ask_variables_on_launch | default(false) }}"
              ask_limit_on_launch: "{{ jt_detail.json.ask_limit_on_launch | default(false) }}"
              ask_tags_on_launch: "{{ jt_detail.json.ask_tags_on_launch | default(false) }}"
              ask_skip_tags_on_launch: "{{ jt_detail.json.ask_skip_tags_on_launch | default(false) }}"
              ask_job_type_on_launch: "{{ jt_detail.json.ask_job_type_on_launch | default(false) }}"
              ask_verbosity_on_launch: "{{ jt_detail.json.ask_verbosity_on_launch | default(false) }}"
              ask_diff_mode_on_launch: "{{ jt_detail.json.ask_diff_mode_on_launch | default(false) }}"
              extra_vars: "{{ jt_detail.json.extra_vars | default('') }}"
              job_tags: "{{ jt_detail.json.job_tags | default('') }}"
              skip_tags: "{{ jt_detail.json.skip_tags | default('') }}"
              limit: "{{ jt_detail.json.limit | default('') }}"
              verbosity: "{{ jt_detail.json.verbosity | default(0) }}"
              survey_enabled: "{{ jt_detail.json.survey_enabled | default(false) }}"

        - name: Add inventory to payload (only if mapped)
          ansible.builtin.set_fact:
            jt_payload: "{{ jt_payload | combine({'inventory': mapped_inventory_id}) }}"
          when:
            - mapped_inventory_id is defined
            - mapped_inventory_id is not string  # basic guard

        - name: Create template (when missing)
          ansible.builtin.uri:
            url: "{{ awx_api_base }}/job_templates/"
            method: POST
            headers: "{{ awx_headers }}"
            validate_certs: "{{ tower_verify_ssl | bool }}"
            body_format: json
            body: "{{ jt_payload }}"
            return_content: true
            status_code: [200, 201]
          register: jt_created
          when: (dst_jt_lookup.json.count | int) == 0

        - name: Update template (when exists)
          ansible.builtin.uri:
            url: "{{ awx_api_base }}/job_templates/{{ dst_jt_lookup.json.results[0].id }}/"
            method: PATCH
            headers: "{{ awx_headers }}"
            validate_certs: "{{ tower_verify_ssl | bool }}"
            body_format: json
            body: "{{ jt_payload }}"
            return_content: true
            status_code: [200]
          register: jt_updated
          when: (dst_jt_lookup.json.count | int) > 0

        - name: Set target template id (created/updated)
          ansible.builtin.set_fact:
            _target_jt_id_effective: >-
              {{
                ((dst_jt_lookup.json.count | int) == 0)
                | ternary(jt_created.json.id, dst_jt_lookup.json.results[0].id)
              }}

        # -------------------------
        # Survey copy (if enabled)
        # -------------------------
        - name: Apply survey spec if survey enabled and survey endpoint returned spec
          ansible.builtin.uri:
            url: "{{ awx_api_base }}/job_templates/{{ _target_jt_id_effective }}/survey_spec/"
            method: POST
            headers: "{{ awx_headers }}"
            validate_certs: "{{ tower_verify_ssl | bool }}"
            body_format: json
            body: "{{ jt_survey.json }}"
            status_code: [200, 201]
          when:
            - (jt_detail.json.survey_enabled | default(false)) | bool
            - jt_survey is defined
            - jt_survey.json is defined
            - (jt_survey.json | type_debug) == 'dict'
            - (jt_survey.json.name is defined) or (jt_survey.json.spec is defined) or (jt_survey.json.description is defined)
          failed_when: false

        # -------------------------
        # Credential attach (best-effort)
        # -------------------------
        - name: Attach matched credentials (only if none missing, or allowed to proceed)
          ansible.builtin.uri:
            url: "{{ awx_api_base }}/job_templates/{{ _target_jt_id_effective }}/credentials/"
            method: POST
            headers: "{{ awx_headers }}"
            validate_certs: "{{ tower_verify_ssl | bool }}"
            body_format: json
            body:
              id: "{{ cred_id }}"
            status_code: [200, 201, 204]
          loop: "{{ matched_cred_ids }}"
          loop_control:
            loop_var: cred_id
          when:
            - (matched_cred_ids | length) > 0
            - (missing_cred_names | length) == 0
          failed_when: false
          changed_when: false

        - name: Mark template copied
          ansible.builtin.set_fact:
            copied_templates: "{{ copied_templates + [jt_detail.json.name] }}"
          when:
            - (create_templates_without_missing_creds | bool) or ((missing_cred_names | length) == 0)

      loop: "{{ selected_templates }}"
      loop_control:
        label: "{{ item.name }}"

    # ---------------------------------------------------------------------
    # Summary
    # ---------------------------------------------------------------------
    - name: Copy summary
      ansible.builtin.debug:
        msg:
          - "Copy complete. Source org='{{ source_org_name }}' -> Target org='{{ target_org_name }}'"
          - "Templates selected: {{ selected_template_names | length }}"
          - "Templates copied: {{ copied_templates | length }}"
          - "Templates with missing creds (created without creds): {{ templates_missing_creds | length }}"
          - "Templates with inventory not mapped: {{ templates_inventory_not_mapped | length }}"
          - "If creds are missing, re-run after you create the customer SP credential in the target org."